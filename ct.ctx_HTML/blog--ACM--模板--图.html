<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>图</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="2019.html">2019</a></p>

<ol>
<li><a href="2019--March.html">March</a></li>
<ol>
<li><a href="2019--March--11_Mon.html">11 Mon</a></li>
<li><a href="2019--March--12.html">12</a></li>
<li><a href="2019--March--13.html">13</a></li>
<li><a href="2019--March--14.html">14</a></li>
<li><a href="2019--March--15.html">15</a></li>
<li><a href="2019--March--16_Sat.html">16 Sat</a></li>
<li><a href="2019--March--17_Sun.html">17 Sun</a></li>
<li><a href="2019--March--19.html">19</a></li>
<li><a href="2019--March--20_Wed.html">20 Wed</a></li>
<li><a href="2019--March--21_Thu.html">21 Thu</a></li>
<li><a href="2019--March--22_Fri.html">22 Fri</a></li>
<li><a href="2019--March--23_Sat.html">23 Sat</a></li>
<li><a href="2019--March--24_Sun.html">24 Sun</a></li>
<li><a href="2019--March--25_Mon.html">25 Mon</a></li>
<li><a href="2019--March--26_Tue.html">26 Tue</a></li>
<li><a href="2019--March--27_Wed.html">27 Wed</a></li>
<li><a href="2019--March--29_Fri.html">29 Fri</a></li>
<li><a href="2019--March--31_Sun.html">31 Sun</a></li>
</ol>
<li><a href="2019--April.html">April</a></li>
<ol>
<li><a href="2019--April--01_Mon.html">01 Mon</a></li>
<li><a href="2019--April--08_Mon.html">08 Mon</a></li>
<li><a href="2019--April--09_Tue.html">09 Tue</a></li>
<li><a href="2019--April--10_Wed.html">10 Wed</a></li>
<li><a href="2019--April--11_Thu.html">11 Thu</a></li>
<li><a href="2019--April--12_Fri.html">12 Fri</a></li>
<li><a href="2019--April--13_Sat.html">13 Sat</a></li>
<li><a href="2019--April--14_Sun.html">14 Sun</a></li>
<li><a href="2019--April--15_Mon.html">15 Mon</a></li>
<li><a href="2019--April--16_Tue.html">16 Tue</a></li>
<li><a href="2019--April--17_Wed.html">17 Wed</a></li>
<li><a href="2019--April--19_Fri.html">19 Fri</a></li>
<li><a href="2019--April--20_Sat.html">20 Sat</a></li>
<li><a href="2019--April--21_Sun.html">21 Sun</a></li>
<li><a href="2019--April--23_Tue.html">23 Tue</a></li>
<li><a href="2019--April--26_Fri.html">26 Fri</a></li>
<li><a href="2019--April--27_Sat.html">27 Sat</a></li>
<li><a href="2019--April--28_Sun.html">28 Sun</a></li>
</ol>
<li><a href="2019--May.html">May</a></li>
<ol>
<li><a href="2019--May--04_Sat.html">04 Sat</a></li>
</ol>
</ol>
<p><a href="think_in_Java.html">think in Java</a></p>

<p><a href="Java应用详解.html">Java应用详解</a></p>

<ol>
<li><a href="Java应用详解--开发环境安装及配置.html">开发环境安装及配置</a></li>
<li><a href="Java应用详解--JDBC数据库连接.html">JDBC数据库连接</a></li>
<li><a href="Java应用详解--数据库连接池.html">数据库连接池</a></li>
<li><a href="Java应用详解--CommonsDbUtils类库.html">CommonsDbUtils类库</a></li>
<li><a href="Java应用详解--JSP.html">JSP</a></li>
<ol>
<li><a href="Java应用详解--JSP--JSP语法.html">JSP语法</a></li>
</ol>
</ol>
<p><a href="Git.html">Git</a></p>

<p><a href="winter-camp.html">winter-camp</a></p>

<ol>
<li><a href="winter-camp--day1.html">day1</a></li>
<li><a href="winter-camp--day2.html">day2</a></li>
<li><a href="winter-camp--day4.html">day4</a></li>
</ol>
<p><a href="keyWords.html">keyWords</a></p>

<ol>
<li><a href="keyWords--vim.html">vim</a></li>
<li><a href="keyWords--linux_terminal.html">linux terminal</a></li>
<li><a href="keyWords--xfceThunar.html">xfceThunar</a></li>
<li><a href="keyWords--rar.html">rar</a></li>
</ol>
<p><a href="Security.html">Security</a></p>

<ol>
<li><a href="Security--从0开始认识.html">从0开始认识</a></li>
<li><a href="Security--准备工作.html">准备工作</a></li>
<li><a href="Security--扫描和嗅探.html">扫描和嗅探</a></li>
</ol>
<p><a href="target.html">target</a></p>

<p><a href="blog.html">blog</a></p>

<ol>
<li><a href="blog--ACM.html">ACM</a></li>
<ol>
<li><a href="blog--ACM--DP.html">DP</a></li>
<ol>
<li><a href="blog--ACM--DP--UVA12563.html">UVA12563</a></li>
<li><a href="blog--ACM--DP--UVA11400.html">UVA11400</a></li>
<li><a href="blog--ACM--DP--UVA11584.html">UVA11584</a></li>
<li><a href="blog--ACM--DP--UVA1625.html">UVA1625</a></li>
</ol>
<li><a href="blog--ACM--模板.html">模板</a></li>
<ol>
<li><a href="blog--ACM--模板--图.html">图</a></li>
<li><a href="blog--ACM--模板--其他.html">其他</a></li>
<li><a href="blog--ACM--模板--线段树.html">线段树</a></li>
</ol>
<li><a href="blog--ACM--2019年ccpc校选赛.html">2019年ccpc校选赛</a></li>
<li><a href="blog--ACM--Codeforces_Round_~554_(Div._2).html">Codeforces Round #554 (Div. 2)</a></li>
</ol>
<li><a href="blog--kali-linux.html">kali-linux</a></li>
<ol>
<li><a href="blog--kali-linux--安装virtualbox虚拟机.html">安装virtualbox虚拟机</a></li>
<li><a href="blog--kali-linux--安装TIM.html">安装TIM</a></li>
<li><a href="blog--kali-linux--使用shadowsocks-qt5.html">使用shadowsocks-qt5</a></li>
<li><a href="blog--kali-linux--文件管理方法修改.html">文件管理方法修改</a></li>
</ol></ol></div>
<div class="page"><h1><b><u>图</u></b></h1>1<h3>. Dijkstra迪杰斯特拉</h3>O(V<sup>2</sup>), 优先级队列优化O(ElogV); V：顶点数， E：边数<br /><div class="codebox"><div class="codebox"><span style="color:#ff9d00;font-weight:700">struct</span>&nbsp;edge&nbsp;{<span style="color:#7f0044;font-weight:400">int</span>&nbsp;to,cost;};<br /><span style="color:#ff9d00;font-weight:700">typedef</span>&nbsp;pair&lt;<span style="color:#7f0044;font-weight:400">int</span>,<span style="color:#7f0044;font-weight:400">int</span>&gt;&nbsp;P;&nbsp;<span style="color:#0088ff;font-weight:400">//first是最短距离，second是顶点的编号</span><br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;V;<span style="color:#0088ff;font-weight:400">//顶点个数</span><br />vector&lt;edge&gt;&nbsp;G[MAXV];<br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;d[MAXV];<br /><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;dijkstra(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;s)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&nbsp;&gt;&nbsp;que;<br />&nbsp;&nbsp;&nbsp;&nbsp;memset(d,INF,<span style="color:#ff9d00;font-weight:700">sizeof</span>&nbsp;d);<br />&nbsp;&nbsp;&nbsp;&nbsp;d[s]&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">0</span>;<br />&nbsp;&nbsp;&nbsp;&nbsp;que.push(P(<span style="color:#ff0044;font-weight:400">0</span>,s));&nbsp;<span style="color:#0088ff;font-weight:400">//把起点推入队列</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>(!que.empty())<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;p&nbsp;=&nbsp;que.top();&nbsp;que.pop();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;v&nbsp;=&nbsp;p.second;&nbsp;<span style="color:#0088ff;font-weight:400">//顶点的编号</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(d[v]&nbsp;&lt;&nbsp;p.first)&nbsp;<span style="color:#ff9d00;font-weight:700">continue</span>;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;i&nbsp;&lt;&nbsp;G[v].size();&nbsp;i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge&nbsp;e&nbsp;=&nbsp;G[v][i];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(d[e.to]&nbsp;&gt;&nbsp;d[v]&nbsp;+&nbsp;e.cost)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[e.to]&nbsp;=&nbsp;d[v]&nbsp;+&nbsp;e.cost;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;que.push(P(d[e.to],e.to));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br /><span style="color:#0088ff;font-weight:400">//------------------------------------我是可爱的分割线---------------------------------------------------------------------------</span><br /><br /><span style="color:#0088ff;font-weight:400">//don't&nbsp;use&nbsp;priority_queue</span><br /><span style="color:#7f0044;font-weight:700">#include&lt;bits/stdc++.h&gt;</span><br /><span style="color:#ff9d00;font-weight:700">using</span>&nbsp;<span style="color:#ff9d00;font-weight:700">namespace</span>&nbsp;std;<br /><br /><span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;INF=<span style="color:#ff0044;font-weight:400">0x3f3f3f3f</span>;<br /><span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;maxn=<span style="color:#ff0044;font-weight:400">10000</span>;<br /><br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;G[maxn][maxn];<br /><span style="color:#7f0044;font-weight:400">bool</span>&nbsp;flag[maxn];<span style="color:#0088ff;font-weight:400">//only&nbsp;need&nbsp;this!!</span><br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;d[maxn];<br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;n,&nbsp;m;<br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;dijkstra(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;v){<br />	<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=<span style="color:#ff0044;font-weight:400">1</span>;&nbsp;i&lt;=n;&nbsp;i++){<br />		d[i]&nbsp;=&nbsp;G[v][i];<br />	}<br />	d[v]=<span style="color:#ff0044;font-weight:400">0</span>;<br />	flag[v]&nbsp;=<span style="color:#ff9d00;font-weight:700">true</span>;<br /><br />	<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;i&lt;n-<span style="color:#ff0044;font-weight:400">1</span>;&nbsp;i++){<br />		<span style="color:#7f0044;font-weight:400">int</span>&nbsp;x&nbsp;=&nbsp;INF,&nbsp;V;<br />		<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;j=<span style="color:#ff0044;font-weight:400">1</span>;j&lt;=n;&nbsp;j++){<br />			<span style="color:#ff9d00;font-weight:700">if</span>(!flag[j]&nbsp;&amp;&amp;&nbsp;d[j]&lt;x){<br />				x=d[j];<br />				V&nbsp;=&nbsp;j;<br />			}<br />		}<br /><br />		flag[V]&nbsp;=&nbsp;<span style="color:#ff9d00;font-weight:700">true</span>;<br />		<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;j=<span style="color:#ff0044;font-weight:400">1</span>;&nbsp;j&lt;=n;j++){<br />			<span style="color:#ff9d00;font-weight:700">if</span>(G[V][j]+d[V]&nbsp;&lt;&nbsp;d[j]){<br />				d[j]=G[V][j]&nbsp;+&nbsp;d[V];<br />			}<br />		}<br />	}<br />}<br /><br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;main(){<br />	cin&nbsp;&gt;&gt;n&nbsp;&gt;&gt;m;<br />	memset(G,&nbsp;INF,&nbsp;<span style="color:#ff9d00;font-weight:700">sizeof</span>&nbsp;G);<br />	<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;i&lt;m;&nbsp;i++){<br />		<span style="color:#7f0044;font-weight:400">int</span>&nbsp;a,&nbsp;b,&nbsp;c;&nbsp;cin&nbsp;&gt;&gt;a&nbsp;&gt;&gt;b&nbsp;&gt;&gt;c;<br />		G[a][b]&nbsp;=c;<br />	}<br />	dijkstra(<span style="color:#ff0044;font-weight:400">1</span>);<br />	<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=<span style="color:#ff0044;font-weight:400">1</span>;&nbsp;i&lt;=n;&nbsp;i++)<br />		cout&nbsp;&lt;&lt;d[i]&nbsp;&lt;&lt;endl;<br />	<span style="color:#ff9d00;font-weight:700">return</span>&nbsp;<span style="color:#ff0044;font-weight:400">0</span>;<br />}<br /><br /></div></div> <br />2. Kruskal O(ElogE)<br /><div class="codebox"><div class="codebox"><span style="color:#7f0044;font-weight:400">int</span>&nbsp;cmp(<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i,&nbsp;<span style="color:#7f0044;font-weight:400">const</span>&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;j)&nbsp;{&nbsp;<span style="color:#ff9d00;font-weight:700">return</span>&nbsp;w[i]&nbsp;&lt;&nbsp;w[j];&nbsp;}<br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;find(x)&nbsp;{&nbsp;<span style="color:#ff9d00;font-weight:700">return</span>&nbsp;(x==p[x])?x:p[x]=find(p[x]);}<br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;Kruskal(){<br />	<span style="color:#7f0044;font-weight:400">int</span>&nbsp;ans=<span style="color:#ff0044;font-weight:400">0</span>;<br />	<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;i&lt;n;&nbsp;i++)&nbsp;p[i]=i;<br />	<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;i&lt;n;&nbsp;i++)&nbsp;r[i]=i;<br />	sort(r,&nbsp;r+m,&nbsp;cmp);<br /><br />	<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;i&lt;n;&nbsp;i++){<br />		<span style="color:#7f0044;font-weight:400">int</span>&nbsp;e=r[i];&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;x=find(u[e]);&nbsp;<span style="color:#7f0044;font-weight:400">int</span>&nbsp;y=find(v[e]);<br />		<span style="color:#ff9d00;font-weight:700">if</span>(x!=y)&nbsp;{&nbsp;ans+=w[e];&nbsp;p[x]=y;&nbsp;}<span style="color:#0088ff;font-weight:400">//make&nbsp;sure&nbsp;there&nbsp;won't&nbsp;get&nbsp;a&nbsp;circle!</span><br />	}<br />	<span style="color:#ff9d00;font-weight:700">return</span>&nbsp;ans;<br />}<br /></div></div><br />3. bellman-ford: O(VE), SPFA(队列优化):O(KE) k是平均入队列次数<br /><div class="codebox"><div class="codebox"><span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;i&lt;n;&nbsp;i++)&nbsp;d[i]=INF;<br />d[<span style="color:#ff0044;font-weight:400">0</span>]=<span style="color:#ff0044;font-weight:400">0</span>;<br /><span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;k=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;k&lt;n-<span style="color:#ff0044;font-weight:400">1</span>;&nbsp;k++){<span style="color:#0088ff;font-weight:400">//n-1轮松弛</span><br />	<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;i&lt;m;&nbsp;i++){<br />		<span style="color:#7f0044;font-weight:400">int</span>&nbsp;x=u[i],&nbsp;y=v[i];<br />		<span style="color:#ff9d00;font-weight:700">if</span>(d[x]&nbsp;&lt;&nbsp;INF)&nbsp;d[y]&nbsp;=&nbsp;min(d[y],&nbsp;d[x]+w[i]);<br />	}<br />}<br /><br /><span style="color:#0088ff;font-weight:400">//------------------------------------我是可爱的分割线---------------------------------------------------------------------------</span><br /><br /><span style="color:#7f0044;font-weight:400">bool</span>&nbsp;bellman_ford(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;s){<br />	queue&lt;<span style="color:#7f0044;font-weight:400">int</span>&gt;&nbsp;Q;<br />	memset(inq,&nbsp;<span style="color:#ff0044;font-weight:400">0</span>,&nbsp;<span style="color:#ff9d00;font-weight:700">sizeof</span>&nbsp;inq);<br />	memset(cnt,&nbsp;<span style="color:#ff0044;font-weight:400">0</span>,&nbsp;<span style="color:#ff9d00;font-weight:700">sizeof</span>&nbsp;cnt);<br />	d[s]=<span style="color:#ff0044;font-weight:400">0</span>;<br />	Q.push(s);<br />	inq[s]&nbsp;=&nbsp;<span style="color:#ff9d00;font-weight:700">true</span>;<br /><br />	<span style="color:#ff9d00;font-weight:700">while</span>(!Q.empty()){<br />		<span style="color:#7f0044;font-weight:400">int</span>&nbsp;u=Q.front();&nbsp;Q.pop();<br />		inq[u]&nbsp;=&nbsp;<span style="color:#ff9d00;font-weight:700">false</span>;<br />		<br />		<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;i&lt;G[u].size();&nbsp;i++){<br />			Edge&nbsp;&amp;e&nbsp;=&nbsp;G[u][i];<br />			<span style="color:#ff9d00;font-weight:700">if</span>(d[u]&nbsp;&lt;&nbsp;INF&nbsp;&amp;&amp;&nbsp;d[e.to]&gt;d[u]+e.dist){<span style="color:#0088ff;font-weight:400">//不允许INF相加，或者得到比INF更大的数</span><br />				d[e.to]&nbsp;=&nbsp;d[u]+e.dist;<br />				p[e.to]&nbsp;=&nbsp;G[u][i];<br />				<span style="color:#ff9d00;font-weight:700">if</span>(!inq[e.to]){&nbsp;Q.push(e.to);&nbsp;inq[e.to]=<span style="color:#ff9d00;font-weight:700">true</span>;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>(++cnt[e.to]&gt;n)&nbsp;<span style="color:#ff9d00;font-weight:700">return</span>&nbsp;<span style="color:#ff9d00;font-weight:700">false</span>;&nbsp;}<span style="color:#0088ff;font-weight:400">//???</span><br />			}<br />		}<br />	}<br />	<span style="color:#ff9d00;font-weight:700">return</span>&nbsp;<span style="color:#ff9d00;font-weight:700">true</span>;<br />}<br /><span style="color:#0088ff;font-weight:400">//怎么用来判断负环呢？有的负环可能不在最短路上。提示：添加一个顶点;&nbsp;bfs:入队次数大于n.&nbsp;dfs:一条路径一个点出现两次</span><br /><span style="color:#0088ff;font-weight:400">//--!!!&nbsp;dfs适用于边少找负环的题，bfs适用于大量数据求最短路。</span><br /><span style="color:#0088ff;font-weight:400">//------------------------------------我是可爱的分割线---------------------------------------------------------------------------</span><br /><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;SPFA(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;u){<br />	vis[u]=<span style="color:#ff0044;font-weight:400">1</span>;<br />	<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=first[u];i;i=e[i].nxt){<br />		<span style="color:#7f0044;font-weight:400">int</span>&nbsp;v=e[i].v;<br />		<span style="color:#ff9d00;font-weight:700">if</span>(dis[u]+e[i].w&lt;dis[v]){<br />			<span style="color:#ff9d00;font-weight:700">if</span>(vis[v]||flag){<br />				flag=<span style="color:#ff0044;font-weight:400">1</span>;<br />				<span style="color:#ff9d00;font-weight:700">break</span>;<br />			}<br />			dis[v]=dis[u]+e[i].w;<br />			SPFA(v);<br />		}	<br />	}<br />	vis[u]=<span style="color:#ff0044;font-weight:400">0</span>;<br />}<br />---------------------&nbsp;<br />作者：Leo_JAM&nbsp;<br />来源：CSDN&nbsp;<br />原文：https:<span style="color:#0088ff;font-weight:400">//blog.csdn.net/fcb_x/article/details/79807446&nbsp;</span><br />版权声明：本文为博主原创文章，转载请附上博文链接！</div></div><br />4. Floyd，DP<br /><div class="codebox"><div class="codebox"><span style="color:#0088ff;font-weight:400">//initial&nbsp;:&nbsp;d[i][i]=0;&nbsp;d[i][j]=INF;&nbsp;INF太大相加运算会溢出，太小可能会使长度为INF的边变成最短路的一部分</span><br /><span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;k=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;k&lt;n;&nbsp;k++)<br />	<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=<span style="color:#ff0044;font-weight:400">0</span>;i&lt;n;&nbsp;i++)<br />		<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;j=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;j&lt;n;&nbsp;j++)<br />			d[i][j]&nbsp;=&nbsp;min(d[i][j],&nbsp;d[i][k]+d[k][j]);<br />			<br /><br /><span style="color:#0088ff;font-weight:400">//不允许INF相加，或者得到比INF更大的数</span><br /><span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;k=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;k&lt;n;&nbsp;k++)<br />	<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;i=<span style="color:#ff0044;font-weight:400">0</span>;i&lt;n;&nbsp;i++)<br />		<span style="color:#ff9d00;font-weight:700">for</span>(<span style="color:#7f0044;font-weight:400">int</span>&nbsp;j=<span style="color:#ff0044;font-weight:400">0</span>;&nbsp;j&lt;n;&nbsp;j++)<br />			<span style="color:#ff9d00;font-weight:700">if</span>(d[i][j]&lt;INF&nbsp;&amp;&amp;&nbsp;d[k][j]&lt;INF)<br />				d[i][j]&nbsp;=&nbsp;min(d[i][j],&nbsp;d[i][k]+d[k][j]);<br /><span style="color:#0088ff;font-weight:400">//只是关注两点间是否有通路的时候。得到的结果是&nbsp;-&gt;传递闭包</span><br />d[i][j]=d[i][j]||(d[i][k]&nbsp;&amp;&amp;&nbsp;d[k][j]);<br /></div></div></div></div>
</body></html>